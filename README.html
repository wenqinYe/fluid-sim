<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.tex</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="introduction">Introduction</h2>
<p>For this assignment, we leave the realm of deformable objects altogether, instead focusing on objects that do not deform at all. Such rigid body models gain some simplicity via the avoidance of potential energy functions but this is somewhat offset by more complicated generalized coordinates.</p>
<p>Specifically, we will implement an unconstrained rigid body (an exciting torus!) that you can click and pull around.</p>
<h3 id="prerequisite-installation">Prerequisite installation</h3>
<p>On all platforms, we will assume you have installed cmake and a modern c++ compiler on Mac OS X<a href="#¹macusers">¹</a>, Linux<a href="#²linuxusers">²</a>, or Windows<a href="#³windowsusers">³</a>.</p>
<p>We also assume that you have cloned this repository using the <code>--recursive</code> flag (if not then issue <code>git submodule update --init --recursive</code>).</p>
<p><strong>Note:</strong> We only officially support these assignments on Ubuntu Linux 18.04 (the OS the teaching labs are running) and OSX 10.13 (the OS I use on my personal laptop). While they <em>should</em> work on other operating systems, we make no guarantees.</p>
<p><strong>All grading of assignments is done on Linux 18.04</strong></p>
<h3 id="layout">Layout</h3>
<p>All assignments will have a similar directory and file layout:</p>
<pre><code>README.md
CMakeLists.txt
main.cpp
assignment_setup.h
include/
  function1.h
  function2.h
  ...
src/
  function1.cpp
  function2.cpp
  ...
data/
  ...
...</code></pre>
<p>The <code>README.md</code> file will describe the background, contents and tasks of the assignment.</p>
<p>The <code>CMakeLists.txt</code> file setups up the cmake build routine for this assignment.</p>
<p>The <code>main.cpp</code> file will include the headers in the <code>include/</code> directory and link to the functions compiled in the <code>src/</code> directory. This file contains the <code>main</code> function that is executed when the program is run from the command line.</p>
<p>The <code>include/</code> directory contains one file for each function that you will implement as part of the assignment.</p>
<p>The <code>src/</code> directory contains <em>empty implementations</em> of the functions specified in the <code>include/</code> directory. This is where you will implement the parts of the assignment.</p>
<p>The <code>data/</code> directory contains <em>sample</em> input data for your program. Keep in mind you should create your own test data to verify your program as you write it. It is not necessarily sufficient that your program <em>only</em> works on the given sample data.</p>
<h2 id="compilation-for-debugging">Compilation for Debugging</h2>
<p>This and all following assignments will follow a typical cmake/make build routine. Starting in this directory, issue:</p>
<pre><code>mkdir build
cd build
cmake ..</code></pre>
<p>If you are using Mac or Linux, then issue:</p>
<pre><code>make</code></pre>
<h2 id="compilation-for-testing">Compilation for Testing</h2>
<p>Compiling the code in the above manner will yield working, but very slow executables. To run the code at full speed, you should compile it in release mode. Starting in the <strong>build directory</strong>, do the following:</p>
<pre><code>cmake .. -DCMAKE_BUILD_TYPE=Release</code></pre>
<p>Followed by:</p>
<pre><code>make </code></pre>
<p>Your code should now run significantly (sometimes as much as ten times) faster.</p>
<p>If you are using Windows, then running <code>cmake ..</code> should have created a Visual Studio solution file called <code>a5-rigid-bodies.sln</code> that you can open and build from there. Building the project will generate an .exe file.</p>
<p>Why don’t you try this right now?</p>
<h2 id="execution">Execution</h2>
<p>Once built, you can execute the assignment from inside the <code>build/</code> using</p>
<pre><code>./a5-rigid-bodies</code></pre>
<p>While running, you can reset the position of the rigid body by pressing <code>r</code>.</p>
<h2 id="background">Background</h2>
<p>In this assignment we will implement a physics simulation of an unconstrained rigid body in low gravity (e.g. space <a href="https://www.youtube.com/watch?v=8-4P1WPE-Qg">donut</a> which you can interactively fling around the world. The goal is to get a good handle on the kinematics and dynamics of rigid body mechanics, which we will extend in the final assignment to handle collision resolution. Rigid bodies are the first type of object we will encounter that use a truly generalized, generalized coordinate (i.e not just the vertex positions of the mesh) and this complicates both their mathematical treatment and implementation. Let’s dive right in!</p>
<figure>
<img src="images/rb_example.gif" alt="Fun with interactive rigid bodies" /><figcaption aria-hidden="true">Fun with interactive rigid bodies</figcaption>
</figure>
<h2 id="resources">Resources</h2>
<p>Like cloth simulation, comprehensive, readable resources about rigid body dynamics and simulation are hard to find. Some people reccomend this <a href="https://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">book</a>, which is quite mathematical. This <a href="https://animation.rwth-aachen.de/media/papers/2012-EG-STAR_Rigid_Body_Dynamics.pdf">paper</a> provides a detailed overview of rigid body simulation with contact, but is also very equation heavy. In these notes I’ll try to provide a one-stop basic introduction to rigid body dynamics, leaning heavily (as usual) on the variational approach. The rotation matrix derivative is more or less a reproduction of the wonderful paper <a href="https://www.cis.upenn.edu/~cjtaylor/PUBLICATIONS/pdfs/TaylorTR94b.pdf">here</a>.</p>
<h2 id="generalized-coordinates-and-velocities">Generalized Coordinates and Velocities</h2>
<h3 id="generalized-coordinates-for-rigid-motion">Generalized Coordinates for Rigid Motion</h3>
<p>As with all previous assignments, we begin our journey into rigid body simulation by searching for approriate generalized coordinates. Once we have these, all remaining kinematic and dynamic relationships can be derived by turning our variational crank. Rigid bodies are going to be the first time we see generalized coordinates that are not just vertex positions. Why is that ?</p>
<p>The rigid body model is an <em>approximation</em> which we use for objects that do not deform meaningful in the simulated scenario. To be clear <strong>everything deforms</strong> and everything is deforming all the time, its just often so small that we can’t see it, nor does it effect the salient behaviour of our object of interest. In these cases it would be a big waste (of time and memory) to use something like <a href="https://github.com/dilevin/CSC2549-a3-finite-elements-3d">finite elements</a> to simulate said object. So instead we choose generalized coordinates that do not allow the object to deform at all.</p>
<p>Previously when we discussed deformation, we considered how the squared length of a vector in some undeformed space changes under a deformation mapping. What we learned is that, given this undeformed vector <span class="math inline">\(\mathbf{dX}\)</span>, its deformed squared length became</p>
<p><span class="math display">\[ \left|\mathbf{dx}\right|^2 = \mathbf{dX}^TF^TF\mathbf{dX}\]</span></p>
<p>where <span class="math inline">\(F\)</span> is the deformation gradient of the deformation mapping. A good question to ask is *what is required of F so that <span class="math inline">\(\left|\mathbf{dx}\right|^2 = \left|\mathbf{dX}\right|^2\)</span> ? Well, we want <span class="math inline">\(F^TF = I\)</span>, where <span class="math inline">\(I\)</span> is the identity matrix (if you’ve taken <a href="https://github.com/dilevin/computer-graphics-csc418">CSC418</a> then you’ve seen this argument before but wrt the transformation of normal vectors). This property, that the transpose of a matrix is also its inverse, is associated with the special class of matrices called <a href="https://en.wikipedia.org/wiki/Orthogonal_matrix"><strong>orthogonal matrices</strong></a>. Orthogonal matrices thus represent transformations that preserve the distance between all points being transformed. In other words, they do not allow deformation (just what we were looking for).</p>
<p>Additionally, we’ve all learned the painful lesson that we don’t want our simulated objects to turn inside out. So we’d also like the determinant of <span class="math inline">\(F\)</span> to be positive. This eliminates such transformations as reflections, leaving us with rotations as the only valid form of <span class="math inline">\(F\)</span>. Because <span class="math inline">\(F = \frac{\partial \mathbf{x}}{\partial \mathbf{X}} = R\)</span> (here <span class="math inline">\(R\)</span> is a rotation matrix), then</p>
<p><span class="math display">\[ \mathbf{x}^t = R\mathbf{X} + \mathbf{p}\]</span></p>
<p>where <span class="math inline">\(\mathbf{p}\)</span> is a constant of integration and is a rigid body translation. This shows us that the world space position, <span class="math inline">\(\mathbf{x}^t\)</span> of any point in the undeformed space <span class="math inline">\(\mathbf{X}\)</span> is given by the familiar rigid body transformation. This transformation is parameterized by <span class="math inline">\(R\)</span> and <span class="math inline">\(\mathbf{p}\)</span> and so we will choose these as our generalized coordinates <span class="math inline">\(\mathbf{q}\)</span>. Now rather than <span class="math inline">\(\mathbf{q}\)</span> being a set of vertex position, it is a set of rotations and translations for each rigid body in our physical system.</p>
<h3 id="generalized-velocities-for-rigid-motion">Generalized Velocities for Rigid Motion</h3>
<p>Now that we know how to find the world space position of any point, <span class="math inline">\(\mathbf{X}\)</span> in a rigid body, we can take the time derivative to get the generalized velocities.</p>
<p><span class="math display">\[ \mathbf{v}^t = \frac{d\mathbf{x}^t}{dt} = \underbrace{\frac{dR}{dt}\mathbf{X}}_{\mbox{Uh Oh}} + \underbrace{\frac{d\mathbf{p}}{dt}}_{\mbox{linear velocity}}\]</span></p>
<p>Derivatives of rotation matrices are scary, at least I find them scary. That scariness comes from the inherent constraint that <span class="math inline">\(R^R=I\)</span>. Any derivative we take as to respect this. One way to do this is to exploit the fact that rotation matrices are part of a special group of matrices called the <a href="https://en.wikipedia.org/wiki/Orthogonal_group"><em>Special Orthogonal Group</em></a> and are also a <a href="https://en.wikipedia.org/wiki/Lie_group">Lie Group</a>. Lie Groups can be parameterized by an exponential map that takes an element from the Lie Algebra (a linear space) onto the manifold that represents the Lie Group. A convenient fact about rotation matrices is that the can be represented as</p>
<p><span class="math display">\[ R = \mbox{expm}\left(\left[\mathbf{r}\right]\right) \]</span></p>
<p>Here <span class="math inline">\(\mbox{expm}\)</span> is the <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>, <span class="math inline">\(\mathbf{r}\)</span> is a <span class="math inline">\(3\times 1\)</span> vector and <span class="math inline">\(\left[\mathbf{r}\right]\)</span> is the <span class="math inline">\(3 \times 3\)</span>, <a href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix">skew-symmetric</a> matrix created from that vector.We can exploit this formulation to take derivatives in a (slightly) less onerous fashion. As a note, this sort of derivative is often referred to as “geometrically-aware” since it will respect the geometry of the Lie Group.</p>
<p>Ok, lets proceed by infinitesimally perturbing our rotation matrix. We can do this by adding an infinitesimal multiple of another skew-symmetric matrix <span class="math inline">\([\Delta \mathbf{r}]\)</span>, which gives us</p>
<p><span class="math display">\[ R + \Delta R = \mbox{expm}\left(\left[\mathbf{r}\right]+\alpha\left[\Delta\mathbf{r}\right]\right) \]</span></p>
<p>where the scalar, <span class="math inline">\(\alpha\)</span> controls the magnitude of the perturbation. Since this perturbation is meant to be infinitesimally small, <span class="math inline">\(\alpha\)</span> is limited towards <span class="math inline">\(0\)</span>.</p>
<p>What remains is to deal with <span class="math inline">\(\mbox{expm}\)</span>. To do this we are going to replace the exponential operator with its infinite series. This let’s us concoct the following:</p>
<p><span class="math display">\[ \left(R + \Delta R\right)\mathbf{X} = \left(I + \left[\mathbf{r}\right]+\alpha\left[\Delta\mathbf{r}\right] + \frac{1}{2}\left(\left[\mathbf{r}\right]+\alpha\left[\Delta\mathbf{r}\right]\right)\left(\left[\mathbf{r}\right]+\alpha\left[\Delta\mathbf{r}\right]\right)\cdots\right)\mathbf{X} \]</span></p>
<p>Now we are going to compute <span class="math inline">\(\frac{d R}{d\alpha} = \lim_{\alpha\rightarrow 0}\frac{\partial R + \Delta R}{\partial \alpha}\)</span>. This is called a <a href="https://en.wikipedia.org/wiki/Differential_of_a_function">differential</a> and it represents a directional derivative, the change in a function if you move in a particular direction. In this case our direction is <span class="math inline">\(\left[\Delta\mathbf{r}\right]\)</span>. The differential is really doing two things at once. The first is computing the directional derivative around some point <span class="math inline">\(\left[\mathbf{r}\right]+\alpha\left[\Delta\mathbf{r}\right]\)</span>, while the second is using the limit to “move” the point at which the derivative is evaluated back to <span class="math inline">\(\left[\mathbf{r}\right]\)</span>. <strong>NOTE:</strong> this limit is incredibly helpful. It means we can ignore any terms in the above equation that are functions of <span class="math inline">\(\alpha\)</span>, since it will become zero.</p>
<p>A little bit of exciting calculus, followed by some less exciting algebra should convince you that</p>
<p><span class="math display">\[\frac{d R}{d\alpha}\mathbf{X} = lim_{\alpha\rightarrow 0}\frac{\partial R + \Delta R}{\partial \alpha} = \left(I + \left[\mathbf{r}\right] + \frac{1}{2}\left[\mathbf{r}\right]\left[\mathbf{r}\right] + \cdots\right)\left[\Delta\mathbf{r}\right]\mathbf{X}\]</span></p>
<p>But wait, there’s more !! We can simplify a bit further by realizing that <span class="math inline">\(\mbox{\expm}\)</span> has survived the differential in its infinite series form (maybe not surprising given how exponentials usually persist through derivatives). So at the end of it all we get</p>
<p><span class="math display">\[\frac{d R}{d\alpha}\mathbf{X} = \mbox{expm}\left(\left[\mathbf{r}\right]\right)\left[\Delta \mathbf{r}\right]\mathbf{X} = R\left[\Delta \mathbf{r}\right]\mathbf{X}\]</span></p>
<p>Which is not half bad. For the full details of these sorts of derivations, I cannot reccomend this <a href="https://www.cis.upenn.edu/~cjtaylor/PUBLICATIONS/pdfs/TaylorTR94b.pdf">paper</a> enough.</p>
<p>Now our remaining task is to figure out how this relates to the time derivative we were <strong>originally trying to take</strong>.</p>
<h4 id="what-does-it-all-mean">What does it all mean ?</h4>
<p>Let’s start reinterpreting all of this through a physical lens, starting with <span class="math inline">\(\alpha\)</span>. In our case, we aren’t differentiating wrt to an arbitrary parameter, but rather by a time. This means, for us, <span class="math inline">\(\alpha\)</span> is really <span class="math inline">\(t\)</span>. Therefore what we really computed was <span class="math inline">\(\frac{d R}{dt}\mathbf{X}\)</span>. Well that’s lucky, otherwise I would’ve just wasted a whole bunch of time.</p>
<p>The final piece of the puzzle is the meaning of <span class="math inline">\(\left[\Delta r\right]\)</span>. Let’s start by figuring out what units <span class="math inline">\(\left[\Delta r\right]\)</span> is in. When we perturb the rotation matrix we compute <span class="math inline">\(\left[\mathbf{r}\right]+t\left[\Delta\mathbf{r}\right]\)</span>. If <span class="math inline">\(t\)</span> is in seconds, then <span class="math inline">\(\left[\Delta\mathbf{r}\right]\)</span> is <span class="math inline">\(\frac{*something*}{s}\)</span>. Which means its a velocity. Wow, that is really quite useful. Let’s see if we can pin down what type of velocity it is. To do this, we need to recognize that a <span class="math inline">\(3\times3\)</span> skew-symmetric matrix multiplying a vector is really encoding a <a href="https://en.wikipedia.org/wiki/Cross_product">cross-product</a>. So</p>
<p><span class="math display">\[\left[\Delta r\right]\mathbf{X} = \Delta r\times\mathbf{X}\]</span></p>
<p>If you remember your high-school physics (and I certainly do not), you will recall that some velocity, crossed with a position in space is an <a href="https://en.wikipedia.org/wiki/Angular_velocity">angular velocity</a>, the rate of rotation of a point around the origin of a space. Let’s use <span class="math inline">\(\Omega\)</span> to represent the angular velocity vector and let’s start doing that now: <span class="math inline">\(\left[\Delta r\right]\mathbf{X} = \Omega\times\mathbf{X} = \left[\Omega\right]\mathbf{X}\)</span>.</p>
<p>There’s one last missing piece, which is our rotation matrix <span class="math inline">\(R\)</span>. One of the hardest things to keep straight in rigid body mechanics is in what space quantities are defined in. Remember, that <span class="math inline">\(R\)</span> is mapping vectors between the undeformed (often called the body space) . Normally these vectors are position vectors (the vector from the origin of a space to a point in that same space). But they can also be other things, like velocities! Remember our time derivative is <span class="math inline">\(R\left[\Omega\right]\mathbf{X}\)</span> – that rotation matrix is mapping the angular velocity, <span class="math inline">\(\left[\Omega\right]\)</span>, from the undeformed space to the world. This means that <span class="math inline">\(\Omega\)</span> is defined in the undeformed space. Now, some people will leave things at that, but I find it a bit weird, especially since in all the previous assignments our velocities are defined in the world space. So I’m going to define a world space angular velocity, <span class="math inline">\(\omega\)</span>, so that <span class="math inline">\(R^T\omega = \Omega\)</span>. After all this we arrive at</p>
<p><span class="math display">\[ \mathbf{v}^t= R\left[\mathbf{X}\right]^TR^T\omega + \dot{\mathbf{p}} \]</span></p>
<p>where the final rearrangement (swapping <span class="math inline">\(R^T\omega\)</span> and <span class="math inline">\(\mathbf{X}\)</span>) exploits the properties of skew symmetric matrices. Now we can finally chose <span class="math inline">\(\omega\)</span> and <span class="math inline">\(\dot{\mathbf{p}}\)</span> as our generalized velocities. As is typical, we would like to rewrite this in matrix form, and so it becomes</p>
<p><span class="math display">\[ \mathbf{v}^t= \underbrace{\begin{bmatrix}R\left[\mathbf{X}\right]^TR^T &amp; I\end{bmatrix}}_{N\left(\mathbf{X}\right)}\underbrace{\begin{bmatrix}\omega \\ \dot{\mathbf{p}}\end{bmatrix}}_{\dot{\mathbf{q}}} \]</span></p>
<p>where <span class="math inline">\(N\left(\mathbf{X}\right)\)</span> is the <em>rigid body jacobian</em> (sometimes written as <span class="math inline">\(\Gamma\)</span>).</p>
<p><strong>Important Note:</strong> matrix exponentials can be expensive to compute. However, for the special orthogonal group, in 3-dimensions, there’s a beautiful analytical short cut called <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues’ Rotation Formula</a> (note the “s”). You will implement this for the assignment.</p>
<h2 id="kinetic-energy">Kinetic energy</h2>
<p>We finally reach a point where the elegance of the variational approach starts to kick in. As usual we define kinetic energy as</p>
<p><span class="math display">\[T = \frac{1}{2}\int_{\mbox{object}}\rho\dot{\mathbf{q}}^TN\left(\mathbf{X}\right)^TN\left(\mathbf{X}\right)\dot{\mathbf{q}} d\mathbf{X}\]</span></p>
<p>By direct substitution we end up with</p>
<p><span class="math display">\[T = \frac{1}{2}\begin{bmatrix}\omega^T &amp; \dot{\mathbf{p}}^T\end{bmatrix}\underbrace{\left(\begin{bmatrix} R &amp; 0 \\ 0 &amp; I \end{bmatrix}\underbrace{\left(\int_{\mbox{object}}\rho \begin{bmatrix} \left[\mathbf{X}\right]\left[\mathbf{X}\right]^T &amp; \left[\mathbf{X}\right] \\ \left[\mathbf{X}\right]^T &amp; I \end{bmatrix}d\mathbf{X}\right)}_{M_0}\begin{bmatrix} R^T &amp; 0 \\ 0 &amp; I \end{bmatrix}\right)}_{M}\begin{bmatrix}\omega \\ \dot{\mathbf{p}}\end{bmatrix}\]</span></p>
<p>The bad news is that <span class="math inline">\(M\)</span> is no longer constant, it depends on the orientation of the rigid body, but the partial good news, is that a big chunk of it, <span class="math inline">\(M_0\)</span> can be precomputed. Plus, we can make our lives a bit easier by looking at some individual components of <span class="math inline">\(M_0\)</span>.</p>
<p>First, note that the lower-right block of <span class="math inline">\(M_0\)</span> is <span class="math inline">\(\int_{\mbox{object}} \rho I d\mathbf{X}\)</span>. This integral is trivially equal to <span class="math inline">\(mI\)</span> where <span class="math inline">\(m\)</span> is the mass of the entire object.</p>
<p>Second, let’s consider the off-diagonal blocks, of the form <span class="math inline">\(\int_{\mbox{object}} \rho \left[\mathbf{X}\right] d\mathbf{X}\)</span> (or the transpose). Remember that each entry of <span class="math inline">\(\left[\mathbf{X}\right]\)</span> is just a component (either <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span>, <span class="math inline">\(Z\)</span>) of <span class="math inline">\(\mathbf{X}\)</span>. So the entries of this matrix are one of <span class="math inline">\(X^* = \int_{\mbox{object}} \rho X dX\)</span>, <span class="math inline">\(Y^* = \int_{\mbox{object}} \rho Y dY\)</span>, <span class="math inline">\(Z^* = \int_{\mbox{object}} \rho Z dZ\)</span> (or their negations).</p>
<p>What’s interesting is that the vector <span class="math inline">\(\frac{1}{m}\begin{bmatrix} X^* &amp; Y^* &amp; Z^*\end{bmatrix}^T\)</span> is the <a href="https://en.wikipedia.org/wiki/Center_of_mass">center-of-mass</a> of the object. All this time I’ve been using <span class="math inline">\(\mathbf{X}\)</span> to represent a point in the undeformed space of a rigid body – and I <strong>never</strong> chose the origin of the space (how naughty of me). Well, now I’m going to make a choice, one which will make my life a lot easier going forward. I’m going to choose the origin of the undeformed space to be <strong>the center-of-mass</strong>. This means that by definition <span class="math inline">\(\frac{1}{m}\begin{bmatrix} X^* &amp; Y^* &amp; Z^*\end{bmatrix}^T=0\)</span>. Because <span class="math inline">\(m\)</span> is greater than zero by definition, the off-diagonal blocks of <span class="math inline">\(M_0\)</span> become <strong>zero</strong>.</p>
<p>This choice of origin also gives our generalized coordinates and velocities more meaning. Our rotation and translation variables are really measuring rotation around, and translation of, the center-of-mass of our object.</p>
<p>After all this we get a drastically nicer version of <span class="math inline">\(M_0\)</span> which is</p>
<p><span class="math display">\[M_0 = \begin{bmatrix}\int_{\mbox{object}}\rho\left[\mathbf{X}\right]\left[\mathbf{X}\right]^Td\mathbf{X} &amp; 0 \\ 0 &amp; mI \end{bmatrix}\]</span></p>
<p>This version of <span class="math inline">\(M_0\)</span> has two convenient properties. First, it completely decouples the effect of angular and linear velocities on kinetic energy (this will make the equations of motion nicer). Second, we only have one tricky integral to evaluate.</p>
<p>One way you could compute the remaining integrals (upper left block and mass) would be to tetrahedralize your simulation mesh and use quadrature. That’s a bit unsatisfying because it adds an extra layer of <a href="https://github.com/alecjacobson/geometry-processing-csc2520">geometry processing</a> to the proceedings (and who wants that ?). For this assignment we are going to do something somewhat more satisfying …</p>
<h3 id="surface-only-integration">Surface-Only Integration</h3>
<p>The method we will use for integration was popularized Brian Mirtich <a href="https://faculty.math.illinois.edu/~redavid2/PW/TimsPaper.pdf">here</a>. It uses the <a href="https://en.wikipedia.org/wiki/Divergence_theorem">divergence theorem</a> to convert volume integrals into surface integrals and thus allows there evaluation using a surface, rather than a volumetric discretization. The basic idea is to rephrase integrals of the type</p>
<p><span class="math display">\[\int_{\mbox{volume}} f\left(\mathbf{X}\right) d\mathbf{X}\]</span></p>
<p>to</p>
<p><span class="math display">\[\int_{\mbox{volume}} \nabla\cdot \mathbf{g}\left(\mathbf{X}\right) d\mathbf{X} = \int_{\mbox{surface}} \mathbf{g}\left(\mathbf{X}\right)\cdot\mathbf{n} d\mathbf{X}\]</span></p>
<p>where <span class="math inline">\(f\left(\mathbf{X}\right) = \nabla\cdot \mathbf{g}\left(\mathbf{X}\right)\)</span> and <span class="math inline">\(\mathbf{n}\)</span> is the outward facing surface normal at <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(|\mathbf{n}| = 1\)</span>.</p>
<p>What makes this particularly attractive for rigid body inertia tensors is that <span class="math inline">\(f\left(\mathbf{X}\right)\)</span> is very simple. For instance, for the mass calculation we have <span class="math inline">\(m = \rho\int_{\mbox{volume}} 1 d\mathbf{X}\)</span>. Let’s make an easy choice for the function <span class="math inline">\(\mathbf{g}\left(\mathbf{X}\right) = \begin{bmatrix}X &amp; 0 &amp; 0\end{bmatrix}\)</span>. Therefore our integral becomes</p>
<p><span class="math inline">\(m = \rho\int_{\mbox{surface}} X\cdot n_x d\mathbf{X}\)</span></p>
<p>where <span class="math inline">\(n_x\)</span> is the <span class="math inline">\(x\)</span> component of the surface normal. Because our surfaces are divided up into triangle meshes, we can evaluate this integral one triangle at a time and add up the results which gives -</p>
<p><span class="math display">\[ m = \rho\sum_{i=0}^{|triangles|}\int_{i} Xd\mathbf{X} \cdot n^i_x \]</span></p>
<p>Additionally, because the entries of <span class="math inline">\(\left[\mathbf{X}\right]\left[\mathbf{X}\right]^T\)</span> are all quadratic in <span class="math inline">\(\mathbf{X}\)</span>, similar formulas can be found and applied (Mirtich kindly lists them all in his paper).</p>
<h2 id="potential-energy">Potential Energy</h2>
<p>Since rigid bodies don’t deform, they don’t store any potential energy. Consider this the return you get for persevering through the rotation stuff :)</p>
<h2 id="the-equations-of-motion">The Equations of Motion</h2>
<p>The slightly funny form of the kinetic energy leads to a different set of equations of motion for rigid body simulations. These equations are called <a href="https://en.wikipedia.org/wiki/Euler%27s_equations_(rigid_body_dynamics)">Euler’s equations of rigid motion</a>. They are also the Euler-Lagrange equations for the Principle of Least Action, derived using our rotations and angular velocities as generalized coordinates and velocities. There is a very detailed write up of how this is done <a href="http://www.math.ucsd.edu/~mleok/pdf/samplechap.pdf">here</a>.</p>
<p>As is the usual case we can form the Lagrangian <span class="math inline">\(L = T-V\)</span> where <span class="math inline">\(V=0\)</span> for rigid bodies. Initially it would seem to make sense to use our kinetic energy <span class="math inline">\(T\)</span> from above, which is parameterized by, <span class="math inline">\(\omega\)</span>, the world space angular velocity. Sadly, this will make the derivation very difficult, and here’s why. Recall that</p>
<p><span class="math display">\[\omega = R\Omega\]</span></p>
<p>where <span class="math inline">\(\Omega\)</span> is the world space angular velocity. A small variation to <span class="math inline">\(\omega\)</span> can be constructed by varying <span class="math inline">\(R\)</span> and <span class="math inline">\(\Omega\)</span> together. This is tricky to account for. Rather than deal with things this way, its is easier to work, for a moment, using <span class="math inline">\(\Omega\)</span>. Now our kinetic energy becomes</p>
<p><span class="math display">\[T = \underbrace{\frac{1}{2}\Omega^T \mathcal{I} \Omega}_{T_0} + \frac{1}{2}\underbrace{\dot{\mathbf{p}} mI\dot{\mathbf{p}}}_{T_1}\]</span></p>
<p>where <span class="math inline">\(\mathcal{I}\)</span> is the upper-left block of <span class="math inline">\(M_0\)</span>. I’ve written it out like this because, for this decoupled system we can apply calculus of variations seperately for the rotational and linear parts. Thus we get two sets of equations of motion, one computed by setting <span class="math inline">\(\delta T_0 = 0\)</span> and the other computed by setting <span class="math inline">\(\delta T_1 = 0\)</span>. The second equation uses standard, linear velocities and is handled as usual, leading to</p>
<p><span class="math display">\[ mI\ddot{\mathbf{p}} = \mathbf{f}_ext\]</span></p>
<p>Here I’ve added an external forcing term and we observe that the center-of-mass of the rigid body behaves exactly like a regular particle in 3d.</p>
<p>The rotational component is a little bit tricker because we need to compute <span class="math inline">\(\delta T_0 = \frac{\partial T_0}{\partial \Omega}\delta \Omega\)</span>. Much like our previous rotational time derivative, <span class="math inline">\(\delta \Omega\)</span> must take into account the special structure of the Orthogonal Group. Suppressing all the details, this leads to an extra term in the final equations of motion, known as the <em>Quadratic Velocity Vector</em>. This gives us the equations of motion for the rotational variables as</p>
<p><span class="math display">\[ \mathcal{I}\dot{\Omega} = \Omega\times\left(\mathcal{I}\Omega\right)+\mathcal{\tau}_{ext}\]</span></p>
<p>where <span class="math inline">\(\mathcal{\tau}_{ext}\)</span> is an external torque applied to the system. This is equivalent to to</p>
<p><span class="math display">\[ R\mathcal{I}R^T\dot{\omega} = \omega\times\left(R\mathcal{I}R^T\omega\right)+\tau_{ext} \]</span></p>
<p>where <span class="math inline">\(\tau_{ext}\)</span> becomes the world space external torque.</p>
<p>Now all that remains is to integrate our center-of-mass and angular acceleration equations to produce rigid body motion.</p>
<h2 id="time-integration-of-rotating-objects">Time Integration of Rotating Objects</h2>
<p>Because we have no elastic forces to worry about, we can get away with simpler, explicit time integration (<strong>at least for rigid objects that aren’t spinning too quickly</strong>). As such we will apply an explicit Euler type scheme that works in the following way. Like symplectic Euler, we will first compute new velocities for our objects, and then update their positions. For the center-of-mass (particle) equation, this is done using <a href="https://github.com/dilevin/CSC2549-a1-mass-spring-1d">symplectic Euler</a>, exactly!</p>
<p>To update our angular velocities we can proceed as normal, by which I mean replacing our accelerations with standard first order finite differences. Why is this ok for angular accelerations and velocities ? Because these terms act in relation to the tangent space of our Lie Group. The tangent space is a locally flat space (like Euclidean space) and so we can (for a brief moment) ignore all the difficulties rotations and their orthogonality constraint introduce. This means the first step of our integrator solves</p>
<p><span class="math display">\[ \left(R\mathcal{I}R^T\right)^t\omega^{t+1} = \left(R\mathcal{I}R^T\right)^t\omega^{t} +\Delta t \left(\omega^t\times\left(\left(R\mathcal{I}R^T\right)^t\omega\right)+\tau_{ext}\right) \]</span></p>
<p>This is an explicit integration step, we evaluate all the positional variables and forces at the current time step.</p>
<p>The final tricky part is to update our rotation matrix. Now all the complications return. We can’t just add our new angular velocity to the exiting rotation matrix. Recall from our initial discussion of rotations that the angular velocity equation is <span class="math inline">\(\dot{\mathbf{x}} = \left[\omega^{t+1}\right]\mathbf{x}\)</span>. If <span class="math inline">\(\omega\)</span> is constant, this is a linear ordinary differential equation and can be solved with (you guessed it) the matrix exponential, yielding</p>
<p><span class="math inline">\(\mathbf{x}\left(t+\Delta t\right) = \mbox{expm}\left([\omega^{t+1}\Delta t]\right)\mathbf{x}^t = \mbox{expm}\left([\omega^{t+1}\Delta t]\right)R^t\mathbf{X}^t\)</span></p>
<p>which gives us the updated rotation matrix <span class="math inline">\(R^{t+1} = \mbox{expm}\left([\omega^{t+1}\Delta t]\right)R^t\)</span>.</p>
<p>It’s this set of update equations you will use to implement rigid body dynamics in this assignment.</p>
<h2 id="assignment-implementation">Assignment Implementation</h2>
<p>In this assignment you will implement everything needed to simulate an unconstrained rigid body in free space. This includes the mass matrix integration and the explicit, exponential Euler time integrator. While you are encouraged to consult any linked resources, <strong>DO NOT</strong> use any available source code in your assignment. You must code everything yourself.</p>
<h3 id="implementation-notes">Implementation Notes</h3>
<p>Because the generalized coordinates are no longer just a stacked vector of points, accessing them becomes trickier. To make this a little easier we will use the <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1Map.html"><code>Eigen::Map</code></a> functionality. This let’s you create a proxy linear algebra operator from a raw chunk of memory. In this assignment, the rotation matrix and position vector representing a rigid bodies configuration are flattened out and stored in a single <em>Eigen VectorXd</em>. To extract the rotation matrix from the rigid body indexed by <code>irb</code> you should do the following</p>
<p><code>Eigen::Matrix3d R = Eigen::Map&lt;const Eigen::Matrix3d&gt;(q.segment&lt;9&gt;(12*irb).data());</code></p>
<p>Note that I am using the templated version of the segment method, where the segment size is inside the <code>&lt;&gt;</code>.</p>
<h3 id="rodrigues.cpp">rodrigues.cpp</h3>
<p>The rodrigues formula for computing the marix exponential of a <span class="math inline">\(3\times 3\)</span>, skew-symmetric matrix.</p>
<h3 id="rigid_to_world.cpp">rigid_to_world.cpp</h3>
<p>The rigid transformation from the undeformed space to the world (deformed) space.</p>
<h3 id="rigid_body_jacobian.cpp">rigid_body_jacobian.cpp</h3>
<p>The Jacobian of the rigid-to-world transform.</p>
<h3 id="inertia_matrix.cpp">inertia_matrix.cpp</h3>
<p>Compute the rigid inertia matrix of a 3d object, represented by a surface mesh, via surface only integration.</p>
<h3 id="pick_nearest_vertices.cpp">pick_nearest_vertices.cpp</h3>
<p><strong>Use your code from the previous assignments</strong></p>
<h3 id="dv_spring_particle_particle_dq.cpp">dV_spring_particle_particle_dq.cpp</h3>
<p><strong>Use your code from the previous assignments</strong></p>
<h3 id="exponential_euler.h">exponential_euler.h</h3>
<p>Implement the explicit, exponential Euler time integration scheme.</p>
</body>
</html>
